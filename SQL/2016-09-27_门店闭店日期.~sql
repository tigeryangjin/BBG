--1.门店销售最小最大日期
SELECT O.ORG_NUM,
       MIN(TO_DATE(SUBSTR(T.DT_WID, 2, 8), 'YYYYMMDD')) MIN_DATE,
       MAX(TO_DATE(SUBSTR(T.DT_WID, 2, 8), 'YYYYMMDD')) MAX_DATE
  FROM RADM.W_RTL_SLS_TRX_IT_LC_DY_F T, RADM.W_INT_ORG_D O
 WHERE T.ORG_WID = O.ROW_WID
 GROUP BY O.ORG_NUM;

SELECT TO_DATE('20110101', 'yyyymmdd') + LEVEL - 1
  FROM DUAL
CONNECT BY LEVEL <= TO_DATE('20111231', 'yyyymmdd') -
           TO_DATE('20110101', 'yyyymmdd');

--1.1门店最大销售日期+销售金额
SELECT /*+PARALLEL(16)*/
 O.ORG_NUM,
 TO_DATE(SUBSTR(T.DT_WID, 2, 8), 'YYYYMMDD') DAYS,
 SUM(T.SLS_AMT_LCL - T.RET_AMT_LCL) SALES_AMT
  FROM RADM.W_RTL_SLS_TRX_IT_LC_DY_F T, RADM.W_INT_ORG_D O
 WHERE T.ORG_WID = O.ROW_WID
   AND T.DT_WID != '1' || TO_CHAR(TRUNC(SYSDATE - 1), 'YYYYMMDD') || '000'
   AND EXISTS
 (SELECT 1
          FROM (SELECT /*+PARALLEL(16)*/
                 OM.ORG_NUM, MAX(TM.DT_WID) MAX_DT_WID
                  FROM RADM.W_RTL_SLS_TRX_IT_LC_DY_F TM, RADM.W_INT_ORG_D OM
                 WHERE TM.ORG_WID = OM.ROW_WID
                 GROUP BY OM.ORG_NUM) S
         WHERE O.ORG_NUM = S.ORG_NUM
           AND S.MAX_DT_WID = T.DT_WID)
 GROUP BY O.ORG_NUM, TO_DATE(SUBSTR(T.DT_WID, 2, 8), 'YYYYMMDD')
 ORDER BY 1;

--1.2门店月份销售天数
SELECT O.ORG_NUM, SUBSTR(U.DAYS, 1, 6) MONTH, COUNT(U.DAYS) DAYS
  FROM (SELECT /*+PARALLEL(16)*/
        DISTINCT T.ORG_WID, SUBSTR(T.DT_WID, 2, 8) DAYS
          FROM RADM.W_RTL_SLS_TRX_IT_LC_DY_F T) U,
       RADM.W_INT_ORG_D O
 WHERE U.ORG_WID = O.ROW_WID
 GROUP BY O.ORG_NUM, SUBSTR(U.DAYS, 1, 6)
 ORDER BY 1, 2;

--*******************************************************************
--2.门店销售缺失日期
--*******************************************************************
--2.1
CREATE TABLE BBG_LOC_OPEN_DAY_TMP AS
  SELECT J.ORG_NUM, J.MIN_DATE + LEVEL - 1 DAYS
    FROM (SELECT O.ORG_NUM,
                 MIN(TO_DATE(SUBSTR(T.DT_WID, 2, 8), 'YYYYMMDD')) MIN_DATE,
                 MAX(TO_DATE(SUBSTR(T.DT_WID, 2, 8), 'YYYYMMDD') + 1) MAX_DATE
            FROM RADM.W_RTL_SLS_LC_DY_A T, RADM.W_INT_ORG_D O
           WHERE T.ORG_WID = O.ROW_WID
           GROUP BY O.ORG_NUM) J
   WHERE 1 = 2
  CONNECT BY LEVEL <= J.MAX_DATE - J.MIN_DATE;

--2.2
CREATE TABLE RADM.BBG_MIN_MAX_LOC_SALES_DAY_TMP AS
  SELECT /*+PARALLEL(32)*/
   O.ORG_NUM,
   MIN(TO_DATE(SUBSTR(T.DT_WID, 2, 8), 'YYYYMMDD')) MIN_DATE,
   MAX(TO_DATE(SUBSTR(T.DT_WID, 2, 8), 'YYYYMMDD')) MAX_DATE
    FROM RADM.W_RTL_SLS_TRX_IT_LC_DY_F T, RADM.W_INT_ORG_D O
   WHERE T.ORG_WID = O.ROW_WID
   GROUP BY O.ORG_NUM;

--2.3
CREATE TABLE RADM.BBG_LOC_OPEN_DAY_TMP(ORG_NUM VARCHAR2(30), DAYS DATE);
--1.定义游标，名称为CUR_STU
DECLARE
  CURSOR C_ORG_NUM IS
    SELECT ORG_NUM FROM RADM.W_INT_ORG_D;
  --定义变量，存放游标取出的数据
  I_ORG_NUM INT;
BEGIN
  --2.打开游标CUR_STU
  OPEN C_ORG_NUM;
  --3.将游标的当前行取出存放到变量中
  FETCH C_ORG_NUM
    INTO I_ORG_NUM;
  WHILE C_ORG_NUM%FOUND --游标所指还有数据行，则继续循环
   LOOP
    --打印结果
    INSERT INTO RADM.BBG_LOC_OPEN_DAY_TMP
      SELECT J.ORG_NUM, J.MIN_DATE + LEVEL - 1 DAYS
        FROM (SELECT /*+PARALLEL(16)*/
               T.ORG_NUM, T.MIN_DATE, T.MAX_DATE + 1 MAX_DATE
                FROM RADM.BBG_MIN_MAX_LOC_SALES_DAY_TMP T
               WHERE T.ORG_NUM = I_ORG_NUM) J
      CONNECT BY LEVEL <= J.MAX_DATE - J.MIN_DATE;
    COMMIT;
    --INSERT INTO TEST2 (T1, T2, T3) VALUES (T1, T2, T3);
    --继续将游标所指的当前行取出放到变量中
    FETCH C_ORG_NUM
      INTO I_ORG_NUM;
  END LOOP;
  CLOSE C_ORG_NUM; --4.关闭游标
END;

--5.
SELECT /*+PARALLEL(16)*/
 *
  FROM RADM.BBG_LOC_OPEN_DAY_TMP AD
 WHERE NOT EXISTS
 (SELECT 1
          FROM (SELECT /*+PARALLEL(16)*/
                 O.ORG_NUM,
                 TO_DATE(SUBSTR(A.DT_WID, 2, 8), 'YYYYMMDD') SALES_DAY
                  FROM RADM.W_RTL_SLS_TRX_IT_LC_DY_F A, RADM.W_INT_ORG_D O
                 WHERE A.ORG_WID = O.ROW_WID) YD
         WHERE AD.ORG_NUM = YD.ORG_NUM
           AND AD.DAYS = YD.SALES_DAY)
 ORDER BY 1, 2;
